package LuckyMinus20

import (
	"crypto/tls"
	"errors"
	"io"
	"net"
	"os"
	"time"
)

func Test(timeOut int, address string) (vulnerable bool, err error) {
	if _, _, err := net.SplitHostPort(address); err != nil {
		address = address + ":443"
	}
	deadline := time.Now().Add(time.Duration(timeOut) * time.Second)
	conn, err := tls.DialWithDialer(&net.Dialer{
		Deadline: deadline,
	}, "tcp", address, &tls.Config{
		CipherSuites: []uint16{
			tls.TLS_RSA_WITH_AES_128_CBC_SHA,
			tls.TLS_RSA_WITH_AES_256_CBC_SHA,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
			tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
			tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
		},
		MinVersion:         tls.VersionTLS10,
		MaxVersion:         tls.VersionTLS12,
		InsecureSkipVerify: true,
	})
	if err != nil {
		return false, err
	}
	if err := conn.SetDeadline(deadline); err != nil {
		return false, err
	}
	if _, err := conn.Write([]byte(`$`)); err != nil {
		return false, err
	}
	if _, err := io.Copy(os.Stdout, conn); err != nil {
		if err, ok := err.(*net.OpError); ok {
			switch err.Err.Error() {
			case "record overflow":
				return true, nil
			case "bad record MAC":
				return false, nil
			}
		}
		return false, err
	}
	if err := conn.Close(); err != nil {
		return false, err
	}
	return false, errors.New("expected a remote error")
}
